#!/usr/bin/env python3
"""
ATM Penetration Test Suite
Security-focused testing for ATM implementation

Prerequisites:
1. Bank must be running (./bank bank.atm)
2. Router must be running (./router 3000 3001)
3. User must be created (./init bank.atm alice 1234 100)
4. ATM card must exist (alice.card)

Run with: python3 atm_pentest.py
"""

import subprocess
import time
import os
import sys
import signal
import random
import string
from pathlib import Path

class ATMPenTest:
    def __init__(self):
        self.test_results = []
        self.passed = 0
        self.failed = 0
        self.atm_process = None
        
    def log(self, message, level="INFO"):
        prefix = {
            "INFO": "[*]",
            "PASS": "[+]",
            "FAIL": "[-]",
            "WARN": "[!]",
            "ATTACK": "[#]"
        }
        print(f"{prefix.get(level, '[*]')} {message}")
        
    def run_atm_command(self, commands, timeout=5):
        """Run ATM with a sequence of commands"""
        try:
            input_str = '\n'.join(commands) + '\n'
            proc = subprocess.Popen(
                ['./bin/atm', 'bank.atm'],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            stdout, stderr = proc.communicate(input=input_str, timeout=timeout)
            return stdout, stderr, proc.returncode
        except subprocess.TimeoutExpired:
            proc.kill()
            return None, "TIMEOUT", -1
        except Exception as e:
            return None, str(e), -1
            
    def test_case(self, name, commands, expected_patterns=None, unexpected_patterns=None, should_fail=False):
        """Generic test case runner"""
        self.log(f"Testing: {name}", "ATTACK")
        stdout, stderr, returncode = self.run_atm_command(commands)
        
        if stdout is None:
            self.log(f"FAIL: {name} - {stderr}", "FAIL")
            self.log(f"     Actual output: None (timeout/error)", "INFO")
            self.failed += 1
            return False
            
        # Show actual output
        cleaned_output = stdout.strip().replace('\n', ' | ')
        self.log(f"     Actual output: '{cleaned_output}'", "INFO")
            
        passed = True
        
        if expected_patterns:
            for pattern in expected_patterns:
                if pattern not in stdout:
                    self.log(f"FAIL: {name} - Expected '{pattern}' not found", "FAIL")
                    passed = False
                    
        if unexpected_patterns:
            for pattern in unexpected_patterns:
                if pattern in stdout:
                    self.log(f"FAIL: {name} - Unexpected '{pattern}' found", "FAIL")
                    passed = False
                    
        if passed:
            self.log(f"PASS: {name}", "PASS")
            self.passed += 1
        else:
            self.failed += 1
            
        return passed
        
    # ==================== AUTHENTICATION ATTACKS ====================
            
    def test_command_injection_username(self):
        """Test command injection in username field"""
        malicious_usernames = [
            "alice; ls",
            "alice && cat bank.atm",
            "alice | cat /etc/passwd",
            "alice`whoami`",
            "alice$(whoami)",
            "alice; rm -rf /",
            "alice\ncat bank.atm"
        ]
        
        for username in malicious_usernames:
            self.test_case(
                f"Command Injection: {username}",
                [f"begin-session {username}"],
                expected_patterns=["Usage:", "No such user", "Unable to access"],
                unexpected_patterns=["Authorized"]
            )
            
    def test_path_traversal_username(self):
        """Test path traversal in username field"""
        malicious_usernames = [
            "../bank",
            "../../etc/passwd",
            "../../../etc/shadow",
            "..\\..\\bank.atm",
            "alice/../bank",
            "./bank",
            "/etc/passwd"
        ]
        
        for username in malicious_usernames:
            self.test_case(
                f"Path Traversal: {username}",
                [f"begin-session {username}"],
                expected_patterns=["Usage:", "No such user", "Unable to access"],
                unexpected_patterns=["Authorized", "PIN?"]
            )
            
    def test_buffer_overflow_username(self):
        """Test buffer overflow in username field"""
        # Test various lengths
        lengths = [250, 251, 255, 256, 512, 1024, 4096, 8192]
        
        for length in lengths:
            username = 'A' * length
            self.test_case(
                f"Buffer Overflow Username (len={length})",
                [f"begin-session {username}"],
                expected_patterns=["Usage:", "No such user", "Unable to access"],
                unexpected_patterns=["Authorized"]
            )
            
    def test_format_string_username(self):
        """Test format string vulnerabilities in username"""
        malicious_usernames = [
            "%s%s%s%s%s%s%s",
            "%x%x%x%x%x",
            "%n%n%n%n",
            "alice%s%s%s%s",
            "%08x.%08x.%08x.%08x",
            "%p%p%p%p"
        ]
        
        for username in malicious_usernames:
            self.test_case(
                f"Format String: {username}",
                [f"begin-session {username}"],
                expected_patterns=["Usage:", "No such user", "Unable to access"],
                unexpected_patterns=["Authorized", "0x"]
            )
            
    def test_null_byte_injection(self):
        """Test null byte injection"""
        # Python can't easily test this via stdin, but we try
        self.test_case(
            "Null Byte Injection",
            ["begin-session alice\x00admin"],
            expected_patterns=["Usage:", "No such user", "Unable to access"],
            unexpected_patterns=["Authorized"]
        )
        
    def test_pin_brute_force(self):
        """Test PIN brute force protection"""
        self.log("Testing PIN brute force (trying multiple incorrect PINs)", "ATTACK")
        
        # Try many incorrect PINs
        commands = []
        for i in range(20):
            commands.append("begin-session alice")
            commands.append(f"{i:04d}")  # Wrong PIN
            
        stdout, stderr, _ = self.run_atm_command(commands, timeout=10)
        
        # Show actual output
        if stdout:
            cleaned_output = stdout.strip().replace('\n', ' | ')
            self.log(f"Brute force output: '{cleaned_output}'", "INFO")
            auth_count = stdout.count("Not authorized")
            self.log(f"Attempted {auth_count} failed authentications")
        else:
            self.log(f"Brute force output: None (timeout/error)", "INFO")
            # In a secure system, there should be some protection
            
    def test_pin_timing_attack(self):
        """Test for timing attack vulnerabilities in PIN verification"""
        self.log("Testing PIN timing attack vulnerability", "ATTACK")
        
        # Test if partial PIN matches take longer
        test_pins = ["0000", "1234", "9999", "1111"]
        times = {}
        
        for pin in test_pins:
            start = time.time()
            stdout, stderr, _ = self.run_atm_command(["begin-session alice", pin], timeout=2)
            elapsed = time.time() - start
            times[pin] = elapsed
            # Show actual output for timing test
            if stdout:
                cleaned_output = stdout.strip().replace('\n', ' | ')
                self.log(f"PIN {pin} output: '{cleaned_output}' (time: {elapsed:.3f}s)", "INFO")
            
        self.log(f"PIN timing variations: {times}")
        
    # ==================== SESSION ATTACKS ====================
    
    def test_concurrent_sessions(self):
        """Test if multiple concurrent sessions are prevented"""
        self.test_case(
            "Concurrent Session Prevention",
            [
                "begin-session alice",
                "1234",
                "begin-session alice"
            ],
            expected_patterns=["Authorized", "A user is already logged in"]
        )
        
    def test_session_hijacking_attempt(self):
        """Test session hijacking by switching users mid-session"""
        self.test_case(
            "Session Hijacking Prevention",
            [
                "begin-session alice",
                "1234",
                "begin-session bob"
            ],
            expected_patterns=["A user is already logged in"]
        )
        
    def test_session_fixation(self):
        """Test session fixation attacks"""
        # Try to force a specific session ID (if exposed)
        self.test_case(
            "Session Fixation",
            [
                "begin-session alice",
                "1234",
                "end-session",
                "begin-session alice",
                "1234"
            ],
            expected_patterns=["Authorized"]
        )
        
    # ==================== TRANSACTION ATTACKS ====================
    
    def test_negative_withdrawal(self):
        """Test negative amount withdrawal (credit injection)"""
        self.test_case(
            "Negative Withdrawal Attack",
            [
                "begin-session alice",
                "1234",
                "withdraw -100"
            ],
            expected_patterns=["Usage:", "Invalid amount"],
            unexpected_patterns=["$"]
        )
        
    def test_integer_overflow_withdrawal(self):
        """Test integer overflow in withdrawal amount"""
        overflow_values = [
            "2147483647",  # INT_MAX
            "2147483648",  # INT_MAX + 1
            "4294967295",  # UINT_MAX
            "4294967296",  # UINT_MAX + 1
            "9999999999999999999",
            "18446744073709551615"  # ULLONG_MAX
        ]
        
        for value in overflow_values:
            self.test_case(
                f"Integer Overflow: {value}",
                [
                    "begin-session alice",
                    "1234",
                    f"withdraw {value}"
                ],
                expected_patterns=["Usage:", "Insufficient funds", "Invalid"],
                unexpected_patterns=["$-"]
            )
            
    def test_double_withdrawal(self):
        """Test race condition by rapid withdrawals"""
        self.test_case(
            "Rapid Withdrawal Race Condition",
            [
                "begin-session alice",
                "1234",
                "withdraw 10",
                "withdraw 10",
                "withdraw 10",
                "withdraw 10",
                "withdraw 10"
            ],
            expected_patterns=["Authorized"]
        )
        
    def test_withdrawal_without_auth(self):
        """Test withdrawal without authentication"""
        self.test_case(
            "Unauthenticated Withdrawal",
            ["withdraw 50"],
            expected_patterns=["Not authorized", "No user logged in"],
            unexpected_patterns=["$"]
        )
        
    def test_balance_without_auth(self):
        """Test balance check without authentication"""
        self.test_case(
            "Unauthenticated Balance Check",
            ["balance"],
            expected_patterns=["Not authorized", "No user logged in"],
            unexpected_patterns=["$"]
        )
        
    # ==================== INPUT VALIDATION ATTACKS ====================
    
    def test_malformed_commands(self):
        """Test various malformed commands"""
        malformed = [
            "",
            "    ",
            "\n\n\n",
            "withdraw",
            "withdraw abc",
            "withdraw 10.5",
            "withdraw $10",
            "begin-session",
            "begin-session alice bob",
            "balance extra",
            "end-session extra",
            "unknown-command",
            "WITHDRAW 50",
            "Begin-Session alice"
        ]
        
        for cmd in malformed:
            self.test_case(
                f"Malformed Command: '{cmd}'",
                [cmd],
                expected_patterns=["Usage:", "Invalid", ""],
                unexpected_patterns=["$"]
            )
            
    def test_special_characters_in_amount(self):
        """Test special characters in withdrawal amount"""
        special_amounts = [
            "10;ls",
            "10 && cat bank.atm",
            "10|whoami",
            "10`id`",
            "10$(ls)",
            "10%s%s%s",
            "10\x00"
        ]
        
        for amount in special_amounts:
            self.test_case(
                f"Special Characters in Amount: {amount}",
                [
                    "begin-session alice",
                    "1234",
                    f"withdraw {amount}"
                ],
                expected_patterns=["Usage:", "Invalid"],
                unexpected_patterns=["$"]
            )
            
    # ==================== CRYPTOGRAPHIC ATTACKS ====================
    
    def test_card_file_tampering(self):
        """Test if card file tampering is detected"""
        if os.path.exists("alice.card"):
            self.log("Testing card file integrity check", "ATTACK")
            
            # Backup original
            with open("alice.card", "rb") as f:
                original = f.read()
                
            # Tamper with card file
            with open("alice.card", "rb") as f:
                data = bytearray(f.read())
                
            if len(data) > 0:
                # Flip a random bit
                pos = random.randint(0, len(data) - 1)
                data[pos] ^= 0xFF
                
                with open("alice.card", "wb") as f:
                    f.write(data)
                    
                # Try to use tampered card
                stdout, stderr, _ = self.run_atm_command([
                    "begin-session alice",
                    "1234"
                ])
                
                # Show actual output for tampering test
                if stdout:
                    cleaned_output = stdout.strip().replace('\n', ' | ')
                    self.log(f"Tampered card output: '{cleaned_output}'", "INFO")
                
                # Restore original
                with open("alice.card", "wb") as f:
                    f.write(original)
                    
                if stdout and "Authorized" in stdout:
                    self.log("FAIL: Tampered card accepted!", "FAIL")
                    self.failed += 1
                else:
                    self.log("PASS: Tampered card rejected", "PASS")
                    self.passed += 1
                    
    def test_replay_attack(self):
        """Test replay attack protection"""
        self.log("Testing replay attack protection", "ATTACK")
        # This would require packet capture - noted for manual testing
        self.log("Manual test required: Capture and replay network packets", "WARN")
        
    # ==================== DENIAL OF SERVICE ATTACKS ====================
    
    def test_resource_exhaustion(self):
        """Test resource exhaustion via many commands"""
        self.log("Testing resource exhaustion", "ATTACK")
        
        commands = []
        for i in range(1000):
            commands.append("begin-session alice")
            commands.append("9999")  # Wrong PIN
            
        stdout, stderr, _ = self.run_atm_command(commands, timeout=30)
        
        # Show actual output for resource exhaustion test
        if stdout:
            cleaned_output = stdout.strip().replace('\n', ' | ')
            self.log(f"Resource test output: '{cleaned_output[:200]}...' (truncated)", "INFO")
        
        if stderr == "TIMEOUT":
            self.log("FAIL: System hung on many requests", "FAIL")
            self.failed += 1
        else:
            self.log("PASS: System handled many requests", "PASS")
            self.passed += 1
            
    def test_long_input_dos(self):
        """Test DoS via extremely long inputs"""
        long_input = "A" * 1000000
        
        self.test_case(
            "DoS via Long Input",
            [f"begin-session {long_input}"],
            expected_patterns=["Usage:", "Invalid"],
            unexpected_patterns=[]
        )
        
    # ==================== PRIVILEGE ESCALATION ====================
    
    def test_unauthorized_end_session(self):
        """Test ending session without being logged in"""
        self.test_case(
            "Unauthorized End Session",
            ["end-session"],
            expected_patterns=["No user logged in", "Not authorized"],
            unexpected_patterns=[]
        )
        
    def test_cross_user_access(self):
        """Test accessing another user's account"""
        # Create bob if doesn't exist
        if not os.path.exists("bob.card"):
            subprocess.run(["./bin/init", "bank.atm", "bob", "5678", "200"], 
                         capture_output=True)
        
        self.test_case(
            "Cross-User Access Prevention",
            [
                "begin-session alice",
                "1234",
                "end-session",
                "begin-session bob",
                "1234"  # Try alice's PIN for bob
            ],
            expected_patterns=["Not authorized"],
            unexpected_patterns=[]
        )
        
    # ==================== FILE SYSTEM ATTACKS ====================
    
    def test_atm_file_permissions(self):
        """Test ATM initialization file permissions"""
        if os.path.exists("bank.atm"):
            stat_info = os.stat("bank.atm")
            mode = oct(stat_info.st_mode)[-3:]
            self.log(f"bank.atm permissions: {mode}", "INFO")
            
            # Should not be world-readable
            if int(mode[2]) & 4:
                self.log("WARN: bank.atm is world-readable!", "WARN")
                
    def test_card_file_permissions(self):
        """Test card file permissions"""
        if os.path.exists("alice.card"):
            stat_info = os.stat("alice.card")
            mode = oct(stat_info.st_mode)[-3:]
            self.log(f"alice.card permissions: {mode}", "INFO")
            
    # ==================== PROTOCOL ATTACKS ====================
    
    def test_mitm_detection(self):
        """Test if MITM attacks are detectable"""
        self.log("Manual test: MITM attack requires network interception", "WARN")
        self.log("Use router to inject/modify packets", "INFO")
        
    def test_message_integrity(self):
        """Test message integrity protection"""
        self.log("Manual test: Message tampering via router", "WARN")
        
    # ==================== EDGE CASES ====================
    
    def test_unicode_input(self):
        """Test Unicode/UTF-8 handling"""
        unicode_tests = [
            "Ğ°Ğ»Ğ¸ÑĞ°",  # Cyrillic
            "çˆ±ä¸½ä¸",  # Chinese
            "Ø£Ù„ÙŠØ³",   # Arabic
            "××œ×™×¡",   # Hebrew
            "ğŸ˜€ğŸ˜€ğŸ˜€",  # Emoji
        ]
        
        for username in unicode_tests:
            self.test_case(
                f"Unicode Username: {username}",
                [f"begin-session {username}"],
                expected_patterns=["Usage:", "No such user", "Unable to access"],
                unexpected_patterns=["Authorized"]
            )
            
    def test_whitespace_handling(self):
        """Test whitespace handling in inputs"""
        whitespace_tests = [
            "  alice  ",
            "\talice",
            "alice\t",
            " alice ",
            "ali ce",
            "begin-session  alice",
            "withdraw  50"
        ]
        
        for test in whitespace_tests:
            self.test_case(
                f"Whitespace Test: '{test}'",
                [test, "1234"] if "begin-session" in test else [test],
                expected_patterns=["Usage:", "Invalid", "Not authorized"],
                unexpected_patterns=[]
            )
            
    def test_case_sensitivity(self):
        """Test case sensitivity of commands and usernames"""
        self.test_case(
            "Case Sensitivity - ALICE vs alice",
            ["begin-session ALICE"],
            expected_patterns=["No such user", "Unable to access"],
            unexpected_patterns=["Authorized"]
        )
        
    def test_partial_command(self):
        """Test incomplete command handling"""
        self.test_case(
            "Partial Command",
            ["begin"],
            expected_patterns=["Usage:", "Invalid"],
            unexpected_patterns=["Authorized"]
        )
        
    def run_all_tests(self):
        """Run all penetration tests"""
        self.log("=" * 60)
        self.log("ATM PENETRATION TEST SUITE")
        self.log("=" * 60)
        
        # Check prerequisites
        if not os.path.exists("./bin/atm"):
            self.log("ERROR: ./bin/atm not found. Run 'make' first.", "FAIL")
            return
            
        if not os.path.exists("bank.atm"):
            self.log("ERROR: bank.atm not found. Run init first.", "FAIL")
            return
            
        if not os.path.exists("alice.card"):
            self.log("WARN: alice.card not found. Creating user...", "WARN")
            subprocess.run(["./bin/init", "bank.atm", "alice", "1234", "100"])
            
        self.log("Starting penetration tests...")
        self.log("")
        
        # Authentication Attacks
        self.log("=== AUTHENTICATION ATTACKS ===", "INFO")
        self.test_command_injection_username()
        self.test_path_traversal_username()
        self.test_buffer_overflow_username()
        self.test_format_string_username()
        self.test_null_byte_injection()
        self.test_pin_brute_force()
        self.test_pin_timing_attack()
        
        # Session Attacks
        self.log("\n=== SESSION ATTACKS ===", "INFO")
        self.test_concurrent_sessions()
        self.test_session_hijacking_attempt()
        self.test_session_fixation()
        
        # Transaction Attacks
        self.log("\n=== TRANSACTION ATTACKS ===", "INFO")
        self.test_negative_withdrawal()
        self.test_integer_overflow_withdrawal()
        self.test_double_withdrawal()
        self.test_withdrawal_without_auth()
        self.test_balance_without_auth()
        
        # Input Validation
        self.log("\n=== INPUT VALIDATION ATTACKS ===", "INFO")
        self.test_malformed_commands()
        self.test_special_characters_in_amount()
        
        # Cryptographic Attacks
        self.log("\n=== CRYPTOGRAPHIC ATTACKS ===", "INFO")
        self.test_card_file_tampering()
        self.test_replay_attack()
        
        # DoS Attacks
        self.log("\n=== DENIAL OF SERVICE ATTACKS ===", "INFO")
        self.test_resource_exhaustion()
        self.test_long_input_dos()
        
        # Privilege Escalation
        self.log("\n=== PRIVILEGE ESCALATION ===", "INFO")
        self.test_unauthorized_end_session()
        self.test_cross_user_access()
        
        # File System
        self.log("\n=== FILE SYSTEM SECURITY ===", "INFO")
        self.test_atm_file_permissions()
        self.test_card_file_permissions()
        
        # Protocol
        self.log("\n=== PROTOCOL ATTACKS ===", "INFO")
        self.test_mitm_detection()
        self.test_message_integrity()
        
        # Edge Cases
        self.log("\n=== EDGE CASES ===", "INFO")
        self.test_unicode_input()
        self.test_whitespace_handling()
        self.test_case_sensitivity()
        self.test_partial_command()
        
        # Summary
        self.log("")
        self.log("=" * 60)
        self.log("TEST SUMMARY")
        self.log("=" * 60)
        self.log(f"Passed: {self.passed}")
        self.log(f"Failed: {self.failed}")
        self.log(f"Total:  {self.passed + self.failed}")
        self.log(f"Success Rate: {self.passed / (self.passed + self.failed) * 100:.1f}%" if (self.passed + self.failed) > 0 else "N/A")
        self.log("=" * 60)
        
        return self.failed == 0

if __name__ == "__main__":
    print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           ATM PENETRATION TESTING SUITE                      â•‘
â•‘           Security Assessment Tool                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PREREQUISITES:
1. Ensure bank is running: ./bin/bank bank.atm
2. Ensure router is running: ./bin/router 3000 3001
3. User 'alice' with PIN '1234' should exist
4. Run 'make' to build the project first

Starting tests...
""")
    
    tester = ATMPenTest()
    success = tester.run_all_tests()
    
    sys.exit(0 if success else 1)
